using Godot;
using System;
using System.Collections.Generic;
using State = StateManager.State;

public partial class BirdHunter : NPCNode {

	public override void _Ready(){
		base._Ready();
		m.inv = ResourceFactory.MakeInventory();
		cycleStates = new List<State>(){ State.ROAMING, State.IDLE };
		if (nav != null){
			NavigationServer3D.MapChanged += (arg) => { 
				nav.TargetPosition = Global.level.GetRandomNavPoint(); //TODO how does birdhunter get his next navigation point?
				navReady = true; 
			};
		}
	}

	public override void _Process(double delta){
		base._Process(delta);
		switch (m.state){
			case State.IDLE:
				break;
			case State.ALERT:
				LookAt(target.GlobalPosition);
				break;
			case State.TALKING:
				break;
			case State.ROAMING:
				if (navReady){
					nav.TargetPosition = Global.level.GetRandomNavPoint();
					navReady = true; 
				}
				break;
			case State.ATTACKING:
				break;
			case State.SLEEPING:
				break;
			case State.ACTION:
				break;
			case State.DEAD:
				break;
		}
	}

	public override void _PhysicsProcess(double delta)
	{
		base._PhysicsProcess(delta);
		switch (m.state) {
			case State.ROAMING:
				if (navReady){
					if (!nav.IsNavigationFinished()){
						Vector3 nextPos = nav.GetNextPathPosition();
						
						physBody.Velocity = (nextPos - GlobalPosition).Normalized() *2;
					} else {
						nav.TargetPosition = NextNavPoint();
						EffectsManager.MarkerPoint("navpoint", nav.TargetPosition);
					}
				}
				break;
			case State.IDLE:
				physBody.Velocity = Vector3.Zero;
				break;
		}
		physBody.MoveAndSlide();
	}

	public void OnStateTimeout(){
	}

	public override void HandleCollide(ColliderZone zone, Node other)
	{
		//need to verify that not colliding with self (another node that is attached to this one)
		switch (zone){
			case ColliderZone.Awareness0:
				UpdateState(State.ALERT, other);
				break;
			case ColliderZone.Body:
				physBody.Velocity = (((Node3D)other).Position - Position).Normalized() * 4;
				break;
			default:
				break;
		}
	}

	public override void HandleDecollide(ColliderZone zone, Node other)
	{
		switch (zone){
			case ColliderZone.Awareness0:
				UpdateState(State.IDLE);
				break;
			case ColliderZone.Body:
				physBody.Velocity = Vector3.Zero;
				break;
			default:
				break;
		}
	}

	public bool UpdateState(State s, dynamic payload = null)
	{
		State prev = m.state;
		switch (s){
			case State.IDLE:
				target = null;
				break;
			case State.ALERT:
				target = payload;
				break;
			case State.TALKING:
				break;
			case State.ROAMING:
				nav.TargetPosition = (Vector3) CallDeferred("NextNavPoint");
				break;
			case State.ATTACKING:
				break;
			case State.SLEEPING:
				break;
			case State.ACTION:
				break;
			case State.DEAD:
				break;
		}
		m.state = s;
		return true;
	}

	public Vector3 NextNavPoint(){
		float th = (float)GD.RandRange(0, 2*Mathf.Pi);
		float d = (float)GD.RandRange(0, 10);
		return new Vector3(d*Mathf.Cos(th), 0, d*Mathf.Sin(th)) + GlobalPosition;
	}
}
